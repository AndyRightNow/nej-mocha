#!/usr/bin/env node

const {
    spawn,
    exec
} = require('child_process');
const path = require('path');
const CDP = require('chrome-remote-interface');
const treeKill = require('tree-kill');
const istanbul = require('istanbul');

const server = require('./../server');
const config = require('./../config');
const userConfig = require('./../src/get-user-config');
const {
    printGreen,
    printRed,
    printNewLine,
    print,
    printAndNewLine
} = require('./../src/util');

const maxRetry = 100;

// Spawn the chrome process
const testRunnerProcess = spawn(`"${userConfig.chromePath}"`.replace(/\"/g, ""), [
    userConfig.headless ? "--headless" : "",
    "--remote-debugging-port=9222",
]);

/**
 * Kill the browser and the node process
 * 
 * @param {any} client The client of CDP
 */
function exitBrowserAndProcess(client) {
    if (userConfig.shouldBrowserClosed) {
        treeKill(testRunnerProcess.pid, 'SIGHUP', () => {
            process.exit(0);
        });

        if (client) {
            client.close();
        }
    }
}

let collector = new istanbul.Collector();
let reporter = new istanbul.Reporter();
let sync = true;
let tried = 0;
/** Used to prevent multiple async report printing */
let reportPrintingStarted = false;

function run(Runtime, client) {
    Runtime
        .evaluate({
            expression: config.GLOBAL_PROMISE
        })
        .then((res) => {
            return Runtime.awaitPromise({
                promiseObjectId: res.result.objectId
            });
        })
        .then((res) => {
            if (!res.exceptionDetails && !reportPrintingStarted && userConfig.coverage) {
                reportPrintingStarted = true;
                let coverage = JSON.parse(res.result.value);

                for (let key in coverage) {
                    if (coverage.hasOwnProperty(key)) {
                        let newKey = `../../${key}`;
                        coverage[newKey] = coverage[key];
                        delete coverage[key];
                        coverage[newKey].path = newKey;
                    }
                }

                collector.add(coverage);

                reporter.addAll(userConfig.coverageOptions.reporters);

                reporter.write(collector, sync, function () {
                    exitBrowserAndProcess(client);
                });
            } else {
                exitBrowserAndProcess(client);
            }
        })
        .catch((err) => {
            if (reportPrintingStarted || tried >= maxRetry) {
                exitBrowserAndProcess(client);
            } else {
                run(Runtime, client);
            }
        });
}

CDP((client) => {
    // extract domains
    const {
        Network,
        Page,
        DOM,
        Runtime
    } = client;

    Page.loadEventFired(() => {
        run(Runtime, client);
    });

    // enable events then start
    Promise.all([
            Network.enable(),
            Page.enable(),
            Runtime.enable()
        ]).then(() => {
            printGreen(`  Tests are running...`);

            // Forward test reults
            Runtime.consoleAPICalled((options) => {
                let results = options.args.map(v => v && v.value && typeof v.value === 'string' ? v.value.replace('✓', '\u221A').replace('✖', '\u00D7').replace('․', '.') : v.value).filter(v => !/stdout\:/.test(v));

                let joined = results.join('');
                if (!/^do\s*/.test(joined) &&
                    !/^try to unlock circular/.test(joined)) {
                    console.log.apply(console, results);
                }
            });

            return Page.navigate({
                url: `http://${userConfig.proxy.host}:${userConfig.proxy.port}/${config.TEST_INDEX}`
            });
        })
        .catch((err) => {
            exitBrowserAndProcess(client);
        });
}).on('error', (err) => {
    // cannot connect to the remote endpoint
    printNewLine();
    printRed("  Please close all chrome browser processes before you start the tests.");
    exitBrowserAndProcess();
});