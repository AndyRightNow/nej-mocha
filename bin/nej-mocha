#!/usr/bin/env node

const {
    spawn,
    exec
} = require('child_process');
const path = require('path');
const CDP = require('chrome-remote-interface');
const treeKill = require('tree-kill');

const server = require('./../server');
const config = require('./../config');
const userConfig = require('./../src/get-user-config');
const parseReport = require('./../src/parse-report');
const printReport = require('./../src/print-report');
const {
    printGreen,
    printRed,
    printNewLine,
    print,
    printAndNewLine
} = require('./../src/util');

// Spawn the chrome process
const testRunnerProcess = spawn(`"${userConfig.chromePath}"`.replace(/\"/g, ""), [
    userConfig.headless ? "--headless" : "",
    "--remote-debugging-port=9222",
]);

/**
 * Kill the browser and the node process
 * 
 * @param {any} client The client of CDP
 */
function exitBrowserAndProcess(client) {
    if (userConfig.shouldBrowserClosed) {
        treeKill(testRunnerProcess.pid, 'SIGHUP', () => {
            process.exit(0);
        });

        if (client) {
            client.close();
        }
    }
}
/** To test with userConfig.maxRetries */
let retriedTimes = 0;

/** Global flag to indicate if results are printed or not */
let printedFlag = false;
/** The nodeId of the document node */
let documentNodeId;
/** Global flag to indicate if the tests failed */
let testFailed = false;
/** Global flag to indicate if the test runner is retrying */
let retrying = false;

/**
 * Fetch test results as print it on the console. With limited number of retries
 * 
 * @param {any} promise 
 * @param {any} Runtime 
 * @param {any} DOM 
 * @returns 
 */
function runTestRunner(promise, Runtime, DOM) {
    return promise
        .then(() => {
            return Runtime.evaluate({
                expression: config.GLOBAL_PROMISE
            });
        })
        .then((res) => {
            printGreen("  Tests are running...");

            return Runtime.awaitPromise({
                promiseObjectId: res.result.objectId
            });
        })
        .then((res) => {
            if (res.exceptionDetails) {
                // Still need to store the document node id
                testFailed = true;
            }

            return DOM.getDocument();
        })
        .then((res) => {
            documentNodeId = res.root.nodeId;

            if (testFailed) {
                throw new Error("Tests failed");
            } else {
                return parseReport(DOM, res.root.nodeId);
            }
        })
        .then((res) => {
            return printReport(res);
        })
        .then((res) => {
            exitBrowserAndProcess();
        })
        .catch((err) => {
            retrying = false;

            // Catch promise not found error
            if (err.message.indexOf("not find") !== -1) {
                printAndNewLine(err);

                if (retriedTimes >= userConfig.maxRetries) {
                    printRed(`  Something went wrong. Retried for ${retriedTimes} times and failed.`);
                    exitBrowserAndProcess();
                } else {
                    printRed(`  Something went wrong. Retrying......`);
                    retriedTimes++;
                    retrying = true;
                    runTestRunner(Promise.resolve(), Runtime, DOM);
                }
            }
            // Tests failed
            else {
                if (!printedFlag) {
                    return parseReport(DOM, documentNodeId);
                }
            }
        })
        .then((res) => {
            if (!printedFlag && !retrying) {
                return printReport(res);
            }
        })
        .then(() => {
            if (!retrying) {
                printedFlag = true;

                exitBrowserAndProcess();
            }
        })
        .catch((err) => {
            if (!retrying && !printedFlag) {
                printAndNewLine(err);
                printRed(`  Something went wrong.`);
                exitBrowserAndProcess();
            }
        });
}

CDP((client) => {
    // extract domains
    const {
        Network,
        Page,
        DOM,
        Runtime
    } = client;

    Page.loadEventFired(() => {
        runTestRunner(DOM.enable(), Runtime, DOM);
    });

    // enable events then start
    Promise.all([
            Network.enable(),
            Page.enable(),
            Runtime.enable()
        ]).then(() => {
            // Forward console output
            Runtime.consoleAPICalled((options) => {
                if (options.type === 'log') {
                    let output = options.args.reduce((prev, cur) => `${prev && prev.value ? prev.value : prev} ${cur.value}`);
                    output = typeof output === "string" ? output : output ? output.value : "";

                    if (!/^do\ /.test(output)) {
                        print(`  ${output}`);
                    }
                }
            });

            return Page.navigate({
                url: `http://${userConfig.proxy.host}:${userConfig.proxy.port}/${config.TEST_INDEX}`
            });
        })
        .catch((err) => {
            exitBrowserAndProcess(client);
        });
}).on('error', (err) => {
    // cannot connect to the remote endpoint
    printNewLine();
    printRed("  Please close all chrome browser processes before you start the tests.");
    exitBrowserAndProcess();
});